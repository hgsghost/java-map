# 第三章 并发框架

![concurrentoverview](.\resource\concurrentoverview.png)

## 3.1 从面试题入手多线程

1. 多线程的出现解决了什么问题
2. 线程不安全指什么
3. 并发出现线程不安全的本质是什么
4. java如何解决并发问题
5. 线程安全是非真即假的吗？
6. 线程安全有哪些实现思路
7. 如何理解并发和并行的区别

### 3.1.1 多线程的出现解决了什么问题

计算机中cpu  内存 硬盘的运行速度是有巨大差异的，多线程可以合理利用cpu的高性能，平衡三者的差异，（计算机体系结构，操作系统，编译程序也为了平衡速度差异做了优化）但是也由此带来了新的问题

+ cpu增加了高速缓存--》造成了线程的**可见性**问题
+ 操作系统引入进程/线程概念，分时复用cpu--》造成了**原子性**问题
+ 编译程序添加了指令重排序优化--》造成**有序性**问题

### 3.1.2 线程不安全指什么

多个线程并行或者并发修改同一个变量时 会引起实际结果和理想结果不同

### 3.1.3 并发出现线程不安全的本质是什么

可见性:由cpu缓存引起->线程缓存之间互相不可见造成线程的修改对其他线程不可见,引起可见性问题

原子性:由cpu分时复用引起->转账操作中a账户减钱和b账户加钱应该是原子性的(要么一起成功要么一起失败),cpu分时复用(cpu在各个线程之间切换可能会在两个操作之间从而破坏原子性)引起原子性问题

有序性:指令重排序引起->在执行程序时为了提高性能,可能会有三种重排序

1. 编译器优化重排序
2. 处理器的指令级并行重排序
3. 内存系统重排序(因为处理器中有读/写缓存,使得加载和存储操作看上去是乱序的)

上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。

### 3.1.4 java如何解决并发问题

JMM(java memory model ) java内存模型规范了jvm如何提供按需禁用缓存和编译器优化的方法,具体包括以下:

+ volatile,synchronized,final关键字
+ happens-before规则

如何解决的可见性,原子性,有序性问题?

1. 可见性:volatile关键字来保证可见性,被volatile修饰的变量被修改时会直接更新到主存,其他线程读取时也会直接从主存读取(synchronized和lock也可以保证可见性,因为释放锁之前会将变量修改更新到主存中)
2. 原子性:java使用synchronized和lock保证原子性,两个关键字保证了同一时间只有一个线程执行指令,从而保证了原子性
3. 有序性:volatile可以保证一定程度的有序性,synchronized和lock可以保证单线程执行,相当于保证了有序性,以上是java中保证有序性的手段,JMM中通过happens-before规则保证有序性

#### 3.1.4.1 Happens-Before规则

1.单一线程原则:在一个线程内，在程序前面的操作先行发生于后面的操作。

2.管程锁定规则:一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

3.volatile变量规则:对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

4.线程启动规则:Thread对象的start方法调用先发生于此线程的每一个动作

5.线程加入规则:Thread对象的结束先行发生于join方法返回

6.线程中断规则:对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生,可通过interrupt()方法检测到是否有中断发生

7.对象终结规则:一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始

8.传递性:如果操作a先发生于操作b,操作b先发生于操作c,那么操作a先发生于操作c

### 3.1.5 线程安全:不是一个非真即假的命题

可以将共享数据按照安全程度的强弱顺序来分成以下五类:不可变,绝对线程安全,相对线程安全,线程兼容,线程对立

1. 不可变:final修饰的基本数据类型,string,枚举类型,number部分子类,集合类型可以通过 Collections.unmodifiableXXX()获取一个不可变集合,获取的集合如果修改直接抛异常

2. 绝对线程安全:不管运行时环境如何，调用者都不需要任何额外的同步措施。

3. 相对线程安全:相对线程安全需要保证对这个对象单独的操作是线程安全的,调用时不需要额外的线程安全措施,但是对于特定顺序的连续调用,依然需要额外的同步手段来保证调用的正确性,java中线程安全的对象就是这种例如 Vector,HashTable,Collections的synchronizedCollection()方法包装的集合等

   以下为需要额外代码保证正确运行的案例

   ```java
   public class VectorUnsafeExample {
       private static Vector<Integer> vector = new Vector<>();
       public static void main(String[] args) {
           while (true) {
               for (int i = 0; i < 100; i++) {
                   vector.add(i);
               }
               ExecutorService executorService = Executors.newCachedThreadPool();
               executorService.execute(() -> {
                   for (int i = 0; i < vector.size(); i++) {
                       vector.remove(i);
                   }
               });
               executorService.execute(() -> {
                   for (int i = 0; i < vector.size(); i++) {
                       vector.get(i);
                   }
               });
               executorService.shutdown();
           }
       }
   }
   //结果报错
   Exception in thread "Thread-159738" java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 3
       at java.util.Vector.remove(Vector.java:831)
       at VectorUnsafeExample.lambda$main$0(VectorUnsafeExample.java:14)
       at VectorUnsafeExample$$Lambda$1/713338599.run(Unknown Source)
       at java.lang.Thread.run(Thread.java:745)
   //解决方案
   executorService.execute(() -> {
       synchronized (vector) {
           for (int i = 0; i < vector.size(); i++) {
               vector.remove(i);
           }
       }
   });
   executorService.execute(() -> {
       synchronized (vector) {
           for (int i = 0; i < vector.size(); i++) {
               vector.get(i);
           }
       }
   });
   ```

4. 线程兼容:线程兼容是指类对象本身不是线程安全的但是可以通过同步手段保证对象在并发环境中安全的使用,java中大多数线程不安全的对象就是这种例如 ArrayList HashMap

5. 线程对立:线程对立是指无论使用任何线程安全手段都无法保证线程安全的代码,由于java语言具有多线程特性,此种代码在java中很少见

### 3.1.6 线程安全的实现方法

1. 互斥同步

   synchronized和reentrantlock

2. 非阻塞同步

   CAS 乐观锁 (ABA问题)

3. 无同步方案

   + 栈封闭:其实就是方法的局部变量是分配到栈上的,线程私有,不存在线程并发问题

   + 线程本地存储(Thread Local Storage):实际和栈封闭一样 本质是把变量控制在一个线程范围之内,不存在线程间通信的情况,(注意:在一些场景下尤其是线程池,因为ThreadLocal.ThreadLocalMap的底层数据结构有内存泄露的风险,应该每次使用ThreadLocal后手动调用remove()方法以避免以上问题)

     ![ThreadLocal](.\resource\ThreadLocal.png)

   + 可重入代码(Reentrant Code):这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。

     可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。

### 3.1.7 如何理解并行和并发

并行是多个cpu同时执行,并发是cpu通过切换线程的方式营造出一种同时执行的假象,例如:2个cpu执行4个线程 属于并行并发

java中无法指定线程并发/并行执行(由操作系统决定)
