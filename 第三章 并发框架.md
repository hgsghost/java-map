# 第三章 并发框架

![concurrentoverview](.\resource\concurrentoverview.png)

## 3.1 从面试题入手多线程

1. 多线程的出现解决了什么问题
2. 线程不安全指什么
3. 并发出现线程不安全的本质是什么
4. java如何解决并发问题
5. 线程安全是非真即假的吗？
6. 线程安全有哪些实现思路
7. 如何理解并发和并行的区别

### 3.1.1 多线程的出现解决了什么问题

计算机中cpu  内存 硬盘的运行速度是有巨大差异的，多线程可以合理利用cpu的高性能，平衡三者的差异，（计算机体系结构，操作系统，编译程序也为了平衡速度差异做了优化）但是也由此带来了新的问题

+ cpu增加了高速缓存--》造成了线程的**可见性**问题
+ 操作系统引入进程/线程概念，分时复用cpu--》造成了**原子性**问题
+ 编译程序添加了指令重排序优化--》造成**有序性**问题

### 3.1.2 线程不安全指什么

多个线程并行或者并发修改同一个变量时 会引起实际结果和理想结果不同

### 3.1.3 并发出现线程不安全的本质是什么

可见性:由cpu缓存引起->线程缓存之间互相不可见造成线程的修改对其他线程不可见,引起可见性问题

原子性:由cpu分时复用引起->转账操作中a账户减钱和b账户加钱应该是原子性的(要么一起成功要么一起失败),cpu分时复用(cpu在各个线程之间切换可能会在两个操作之间从而破坏原子性)引起原子性问题

有序性:指令重排序引起->在执行程序时为了提高性能,可能会有三种重排序

1. 编译器优化重排序
2. 处理器的指令级并行重排序
3. 内存系统重排序(因为处理器中有读/写缓存,使得加载和存储操作看上去是乱序的)

上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。

### 3.1.4 java如何解决并发问题

JMM(java memory model ) java内存模型规范了jvm如何提供按需禁用缓存和编译器优化的方法,具体包括以下:

+ volatile,synchronized,final关键字
+ happens-before规则

如何解决的可见性,原子性,有序性问题?

1. 可见性:volatile关键字来保证可见性,被volatile修饰的变量被修改时会直接更新到主存,其他线程读取时也会直接从主存读取(synchronized和lock也可以保证可见性,因为释放锁之前会将变量修改更新到主存中)
2. 原子性:java使用synchronized和lock保证原子性,两个关键字保证了同一时间只有一个线程执行指令,从而保证了原子性
3. 有序性:volatile可以保证一定程度的有序性,synchronized和lock可以保证单线程执行,相当于保证了有序性,以上是java中保证有序性的手段,JMM中通过happens-before规则保证有序性

#### 3.1.4.1 Happens-Before规则

1.单一线程原则:在一个线程内，在程序前面的操作先行发生于后面的操作。

2.管程锁定规则:一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

3.volatile变量规则:对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

4.线程启动规则:Thread对象的start方法调用先发生于此线程的每一个动作

5.线程加入规则:Thread对象的结束先行发生于join方法返回

6.线程中断规则:对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生,可通过interrupt()方法检测到是否有中断发生

7.对象终结规则:一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始

8.传递性:如果操作a先发生于操作b,操作b先发生于操作c,那么操作a先发生于操作c

### 3.1.5 线程安全:不是一个非真即假的命题

可以将共享数据按照安全程度的强弱顺序来分成以下五类:不可变,绝对线程安全,相对线程安全,线程兼容,线程对立

1. 不可变:final修饰的基本数据类型,string,枚举类型,number部分子类,集合类型可以通过 Collections.unmodifiableXXX()获取一个不可变集合,获取的集合如果修改直接抛异常

2. 绝对线程安全:不管运行时环境如何，调用者都不需要任何额外的同步措施。

3. 相对线程安全:相对线程安全需要保证对这个对象单独的操作是线程安全的,调用时不需要额外的线程安全措施,但是对于特定顺序的连续调用,依然需要额外的同步手段来保证调用的正确性,java中线程安全的对象就是这种例如 Vector,HashTable,Collections的synchronizedCollection()方法包装的集合等

   以下为需要额外代码保证正确运行的案例

   ```java
   public class VectorUnsafeExample {
       private static Vector<Integer> vector = new Vector<>();
       public static void main(String[] args) {
           while (true) {
               for (int i = 0; i < 100; i++) {
                   vector.add(i);
               }
               ExecutorService executorService = Executors.newCachedThreadPool();
               executorService.execute(() -> {
                   for (int i = 0; i < vector.size(); i++) {
                       vector.remove(i);
                   }
               });
               executorService.execute(() -> {
                   for (int i = 0; i < vector.size(); i++) {
                       vector.get(i);
                   }
               });
               executorService.shutdown();
           }
       }
   }
   //结果报错
   Exception in thread "Thread-159738" java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 3
       at java.util.Vector.remove(Vector.java:831)
       at VectorUnsafeExample.lambda$main$0(VectorUnsafeExample.java:14)
       at VectorUnsafeExample$$Lambda$1/713338599.run(Unknown Source)
       at java.lang.Thread.run(Thread.java:745)
   //解决方案
   executorService.execute(() -> {
       synchronized (vector) {
           for (int i = 0; i < vector.size(); i++) {
               vector.remove(i);
           }
       }
   });
   executorService.execute(() -> {
       synchronized (vector) {
           for (int i = 0; i < vector.size(); i++) {
               vector.get(i);
           }
       }
   });
   ```

4. 线程兼容:线程兼容是指类对象本身不是线程安全的但是可以通过同步手段保证对象在并发环境中安全的使用,java中大多数线程不安全的对象就是这种例如 ArrayList HashMap

5. 线程对立:线程对立是指无论使用任何线程安全手段都无法保证线程安全的代码,由于java语言具有多线程特性,此种代码在java中很少见

### 3.1.6 线程安全的实现方法

1. 互斥同步

   synchronized和reentrantlock

2. 非阻塞同步

   CAS 乐观锁 (ABA问题)

3. 无同步方案

   + 栈封闭:其实就是方法的局部变量是分配到栈上的,线程私有,不存在线程并发问题

   + 线程本地存储(Thread Local Storage):实际和栈封闭一样 本质是把变量控制在一个线程范围之内,不存在线程间通信的情况,(注意:在一些场景下尤其是线程池,因为ThreadLocal.ThreadLocalMap的底层数据结构有内存泄露的风险,应该每次使用ThreadLocal后手动调用remove()方法以避免以上问题)

     ![ThreadLocal](.\resource\ThreadLocal.png)

   + 可重入代码(Reentrant Code):这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。

     可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。

### 3.1.7 如何理解并行和并发

并行是多个cpu同时执行,并发是cpu通过切换线程的方式营造出一种同时执行的假象,例如:2个cpu执行4个线程 属于并行并发

java中无法指定线程并发/并行执行(由操作系统决定)

## 3.2 线程基础

### 3.2.1 线程的状态

![ThreadStatus](.\resource\ThreadStatus.png)

+ 新建(New)

  线程创建后尚未启动

+ 可运行(Runnable)

  等待cpu时间片或正在运行,包含操作系统线程状态中的Ready和Running

+ 阻塞(Blocking)

  等待获取排它锁,其他线程释放锁时此状态改变

+ 限期等待(Time Waiting)

  常见的是Thread.sleep(),一定时间后被系统自动唤醒,不需要其他线程显式唤醒

  |        进入方法         |                  退出方法                   |
  | :---------------------: | :-----------------------------------------: |
  |     Thread.sleep()      |                  时间结束                   |
  |    Object.wait(xxx)     | 时间结束/Object.notify()/Object.notifyAll() |
  |    Thread.join(xxx)     |          时间结束/目标线程执行完毕          |
  | LockSupport.parkNanos() |                                             |
  | LockSupport.parkUntil() |                                             |

+ 无限期等待(waiting)

  需要被其他线程显式唤醒

  |      进入方法      |              退出方法              |
  | :----------------: | :--------------------------------: |
  |   Object.wait()    | Object.notify()/Object.notifyAll() |
  |   Thread.join()    |            目标线程结束            |
  | LockSupport.park() |                                    |

+ 死亡(Terminated)

  正常或因异常结束

### 3.2.2 线程的使用方式

1. Runnable接口(无返回值)

```java
public class MyRunnable implements Runnable {
    public void run() {
        // ...
    }
    public static void main(String[] args) {
        MyRunnable instance = new MyRunnable();
        Thread thread = new Thread(instance);
        thread.start();
	}
}
```

2. Callable接口(有返回值)

```java
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 123;
    }
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyCallable mc = new MyCallable();
        FutureTask<Integer> ft = new FutureTask<>(mc);
        Thread thread = new Thread(ft);
        thread.start();
        System.out.println(ft.get());
    }

}
```

3. 继承Thread类(java不支持多重继承,此方法缺乏灵活性,不建议使用)

```java
public class MyThread extends Thread {
    public void run() {
        // ...
    }
    public static void main(String[] args) {
        MyThread mt = new MyThread();
        mt.start();
    }
}

```

### 3.2.3 基础线程机制

1. Executor

   Executor管理多个互不干扰的异步任务的执行,无法进行同步操作,Executor是一个接口,有多个具体实现

   + CachedThreadPool:一个任务创建一个线程

   + FixedThreadPool:固定数量的线程池执行所有任务

   + SingleThreadPool:单线程执行所有任务

     ```java
     public static void main(String[] args) {
         ExecutorService executorService = Executors.newCachedThreadPool();
         for (int i = 0; i < 5; i++) {
             executorService.execute(new MyRunnable());
         }
         executorService.shutdown();
     }
     ```

2. Daemon

   守护线程是后台提供服务的线程,程序终止会杀死所有守护线程

   ```java
   public static void main(String[] args) {
       Thread thread = new Thread(new MyRunnable());
       thread.setDaemon(true);
   }
   ```

3. sleep()

   Thread.sleep()方法可能会抛出InterruptedException异常,需要手动处理,线程睡眠过程中不会释放锁,但是会让出cpu时间片执行其他线程

4. yield()

   Thread.yield()方法只是给线程调度器一个建议,建议具有相同优先级的其他线程优先执行

### 3.2.4 线程中断

+ InterruptedException

  当调用线程的interrupt()方法,如果该线程处于阻塞/限期等待/无限期等待状态,会抛出InterruptedException异常,立刻结束该线程(该方法不能中断i/o阻塞和synchronized锁阻塞)

  但是如果该线程处于running状态,只能通过在run()方法中通过调用interrupted()方法获取中断标志位来判断决定是否退出线程(interrupt()方法本质上就是设置线程的中断标志位,阻塞时程序自动监测,正常执行时需要代码手动监测,详情见以下代码)

  ```java
  public class InterruptExample {
      private static class MyThread1 extends Thread {
          @Override
          public void run() {
              try {
                  Thread.sleep(2000);
                  System.out.println("Thread run");
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
      public static void main(String[] args) throws InterruptedException {
          Thread thread1 = new MyThread1();
          thread1.start();
          thread1.interrupt();
          System.out.println("Main run");
      }
  }
  //结果 不需要等2s就会立刻结束线程
  Main run
  java.lang.InterruptedException: sleep interrupted
      at java.lang.Thread.sleep(Native Method)
      at InterruptExample.lambda$main$0(InterruptExample.java:5)
      at InterruptExample$$Lambda$1/713338599.run(Unknown Source)
      at java.lang.Thread.run(Thread.java:745)
  ```

  ```java
  public class InterruptExample {
      private static class MyThread2 extends Thread {
          @Override
          public void run() {
              while (!interrupted()) {
                  // ..
              }
              System.out.println("Thread end");
          }
      }
      public static void main(String[] args) throws InterruptedException {
          Thread thread2 = new MyThread2();
          thread2.start();
          thread2.interrupt();
      }
  }
  //结果
  Thread end
  ```

  

### 3.2.5 Executor的中断操作

调用Executor的shutdown()方法会等待线程执行完成之后再关闭,shutdownNow()方法本质是调用每个线程的interrupt()方法

**Executor中断单个线程**

ExecutorService.submit()方法支持接受一个线程(runnable/callable)的作为参数并返回一个Future<?>对象,可以通过Future.cancel(true)方法中断线程

### 3.2.6 线程互斥同步

java提供两种锁机制来控制多线程对共享资源的互斥访问,一个是jvm实现的synchronized关键字,一个是jdk实现的ReentrantLock,这两个请见后面详解

先说synchronized和ReentrantLock的比较

1. 锁的实现方式

   synchronized是jvm实现的,ReentrantLock是jdk实现的

2. 性能

   jdk8以后对synchronized进行了大幅优化,例如自旋锁等现在二者性能大致相同

3. 等待可中断

   当持有锁的线程长期不释放锁对象时,正在等待的线程可以选择放弃等待,改为处理其他事情

   synchronized不支持,ReentrantLock支持

4. 公平锁

   synchronized和ReentrantLock默认都是非公平锁

   synchronized不支持公平锁,ReentrantLock支持公平锁

5. 锁绑定多个条件

   synchronized不支持,ReentrantLock通过Condition实现绑定多个条件

**选择**

除非使用ReentrantLock的高级功能否则建议synchronized,因为synchronized是jvm实现,收到原生支持,ReentrantLock不受所有jdk版本支持,synchronized不用担心释放锁的问题,jvm会自动释放,ReentrantLock需要手动释放锁

### 3.2.7 线程之间的协作

#### 3.2.7.1  join()

线程a调用线程b的join()方法,线程 a挂起直到线程b结束运行

#### 3.2.7.2  wait()/notify()/notifyAll()

wait()/notify()/notifyAll()是Object的方法,只能使用在同步方法/同步代码块中,否则会抛出illegalMonitorStateExeception异常

调用wait()方法时线程会释放锁并且进入waiting状态,调用notify()/notifyAll()会使锁上的其他线程从waiting状态进入blocking状态

**wait()和sleep()区别**

wait会释放锁 sleep不会释放锁,但会放弃cpu时间片

wait是Object的方法 sleep是Thread的静态方法

#### 3.2.7.3 await()/signal()/signalAll()

juc中提供了Condition类来实现线程间的协调,相比于wait(),await()可以指定特定的condition,因此更加灵活
