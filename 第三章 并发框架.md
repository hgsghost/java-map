# 第三章 并发框架

![concurrentoverview](.\resource\concurrentoverview.png)

## 3.1 从面试题入手多线程

1. 多线程的出现解决了什么问题
2. 线程不安全指什么
3. 并发出现线程不安全的本质是什么
4. java如何解决并发问题
5. 线程安全是非真即假的吗？
6. 线程安全有哪些实现思路
7. 如何理解并发和并行的区别

### 3.1.1 多线程的出现解决了什么问题

计算机中cpu  内存 硬盘的运行速度是有巨大差异的，多线程可以合理利用cpu的高性能，平衡三者的差异，（计算机体系结构，操作系统，编译程序也为了平衡速度差异做了优化）但是也由此带来了新的问题

+ cpu增加了高速缓存--》造成了线程的**可见性**问题
+ 操作系统引入进程/线程概念，分时复用cpu--》造成了**原子性**问题
+ 编译程序添加了指令重排序优化--》造成**有序性**问题

### 3.1.2 线程不安全指什么

多个线程并行或者并发修改同一个变量时 会引起实际结果和理想结果不同

## 3.1.3 并发出现线程不安全的本质是什么

可见性:由cpu缓存引起->线程缓存之间互相不可见造成线程的修改对其他线程不可见,引起可见性问题

原子性:由cpu分时复用引起->转账操作中a账户减钱和b账户加钱应该是原子性的(要么一起成功要么一起失败),cpu分时复用(cpu在各个线程之间切换可能会在两个操作之间从而破坏原子性)引起原子性问题

有序性:指令重排序引起->在执行程序时为了提高性能,可能会有三种重排序

1. 编译器优化重排序
2. 处理器的指令级并行重排序
3. 内存系统重排序(因为处理器中有读/写缓存,使得加载和存储操作看上去是乱序的)

上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。

## 3.1.4 java如何解决并发问题

JMM(java memory model ) java内存模型规范了jvm如何提供按
