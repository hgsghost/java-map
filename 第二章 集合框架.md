# 第二章 集合框架

![集合](.\resource\集合.png)

## 2.1概述

- Collection
  - Set
    - TreeSet (基于红黑树，有序 查询效率为O（logN）  HashSet效率为O（1）)
    - HashSet（基于哈希表实现，无序）
    - LinkedHashSet（查询效率等于HashSet，使用双向链表维护插入顺序）
  - List
    - ArrayList（基于动态数字实现）
    - Vector（基于动态数组，线程安全）
    - LinkedList（基于双向链表，只能顺序访问）
  - Queue
    - LinkedList（可以用它来实现双向队列）
    - PriorityQueue（基于堆结构实现，用来实现优先队列）
- Map
  - TreeMap（基于红黑树）
  - HashMap（基于哈希表）
  - HashTable（基于哈希表 线程安全  遗留类  建议使用 ConcurrentHashMap）
  - LinkedHashMap（基于双向链表 有序）

## 2.2 ArrayList

arraylist默认长度是10 当长度超过时 会扩容为原来的1.5倍

## 2.3 LinkedList

实现了Deque接口和Queue接口

```java
//Queue方法
 	public E peek() {
        final Node<E> f = first;
        return (f == null) ? null : f.item;
    }
    public E element() {
        return getFirst();
    }
    public E poll() {
        final Node<E> f = first;
        return (f == null) ? null : unlinkFirst(f);
    }
    public E remove() {
        return removeFirst();
    }
    public boolean offer(E e) {
        return add(e);
    }
```

```java
//Deque方法
	public boolean offerFirst(E e) {
        addFirst(e);
        return true;
    }
    public boolean offerLast(E e) {
        addLast(e);
        return true;
    }
    public E peekFirst() {
        final Node<E> f = first;
        return (f == null) ? null : f.item;
     }
    public E peekLast() {
        final Node<E> l = last;
        return (l == null) ? null : l.item;
    }
    public E pollFirst() {
        final Node<E> f = first;
        return (f == null) ? null : unlinkFirst(f);
    }
    public E pollLast() {
        final Node<E> l = last;
        return (l == null) ? null : unlinkLast(l);
    }
    public void push(E e) {
        addFirst(e);
    }
    public E pop() {
        return removeFirst();
    }
    public boolean removeFirstOccurrence(Object o) {
        return remove(o);
    }

    public boolean removeLastOccurrence(Object o) {
        if (o == null) {
            for (Node<E> x = last; x != null; x = x.prev) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            for (Node<E> x = last; x != null; x = x.prev) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }
```

